import numpy as np
import os
import subprocess
import matplotlib.pyplot as plt

def read_dust_temperature(filename='dust_temperature.dat'):
    """
    Read the dust temperature file generated by RADMC-3D.
    
    Parameters:
    -----------
    filename : str
        Path to the dust temperature file
        
    Returns:
    --------
    temp_data : ndarray
        Array containing dust temperature data with shape [nr, ntheta, nphi, nspec] or [nr, ntheta, nspec]
    grid_info : dict
        Dictionary containing grid information
    """
    # Read dust temperature data
    with open(filename, 'r') as f:
        iformat = int(f.readline().strip())
        if iformat != 1:
            raise ValueError(f"Unknown file format: {iformat}")
        
        n_cells = int(f.readline().strip())
        n_species = int(f.readline().strip())
        
        # Read temperature data for each cell and species
        temp_data = []
        for i in range(n_species):
            species_temp = []
            for j in range(n_cells):
                species_temp.append(float(f.readline().strip()))
            temp_data.append(np.array(species_temp))
        
        # Convert to numpy array
        temp_data = np.array(temp_data)  # Shape: [n_species, n_cells]
    
    # Read the grid file to get grid information
    try:
        with open('amr_grid.inp', 'r') as f:
            iformat = int(f.readline().strip())
            grid_style = int(f.readline().strip())
            coord_system = int(f.readline().strip())
            grid_info_flag = int(f.readline().strip())
            include_coords = [int(x) for x in f.readline().strip().split()]
            grid_dims = [int(x) for x in f.readline().strip().split()]
            
            # Create grid info dictionary
            grid_info = {}
            
            if coord_system == 0:  # Cartesian
                grid_info['type'] = 'cartesian'
                grid_info['nx'], grid_info['ny'], grid_info['nz'] = grid_dims
                
                # Read cell boundaries
                xi = np.array([float(f.readline().strip()) for _ in range(grid_info['nx'] + 1)])
                yi = np.array([float(f.readline().strip()) for _ in range(grid_info['ny'] + 1)])
                zi = np.array([float(f.readline().strip()) for _ in range(grid_info['nz'] + 1)])
                
                # Calculate cell centers
                xc = 0.5 * (xi[:-1] + xi[1:])
                yc = 0.5 * (yi[:-1] + yi[1:])
                zc = 0.5 * (zi[:-1] + zi[1:])
                
                grid_info['xi'] = xi
                grid_info['yi'] = yi
                grid_info['zi'] = zi
                grid_info['xc'] = xc
                grid_info['yc'] = yc
                grid_info['zc'] = zc
                
                # Reshape temperature data to 3D grid
                nr = grid_info['nx']
                ntheta = grid_info['ny']
                nphi = grid_info['nz']
                
                # Reshape and transpose to match density format
                temp_data = temp_data.reshape(n_species, nphi, ntheta, nr)
                temp_data = temp_data.transpose(3, 2, 1, 0)  # [nr, ntheta, nphi, n_species]
                
            elif coord_system == 100:  # Spherical
                grid_info['type'] = 'spherical'
                grid_info['nr'], grid_info['ntheta'], grid_info['nphi'] = grid_dims
                
                # Read cell boundaries
                ri = np.array([float(f.readline().strip()) for _ in range(grid_info['nr'] + 1)])
                thetai = np.array([float(f.readline().strip()) for _ in range(grid_info['ntheta'] + 1)])
                phii = np.array([float(f.readline().strip()) for _ in range(grid_info['nphi'] + 1)])
                
                # Calculate cell centers
                rc = 0.5 * (ri[:-1] + ri[1:])
                thetac = 0.5 * (thetai[:-1] + thetai[1:])
                phic = 0.5 * (phii[:-1] + phii[1:])
                
                grid_info['ri'] = ri
                grid_info['thetai'] = thetai
                grid_info['phii'] = phii
                grid_info['rc'] = rc
                grid_info['thetac'] = thetac
                grid_info['phic'] = phic
                
                # Reshape temperature data based on dimensionality
                nr = grid_info['nr']
                ntheta = grid_info['ntheta']
                nphi = grid_info['nphi']
                
                if nphi == 1:
                    # 2D case (r, theta)
                    temp_data = temp_data.reshape(n_species, ntheta, nr)
                    temp_data = temp_data.transpose(2, 1, 0)  # [nr, ntheta, n_species]
                else:
                    # 3D case (r, theta, phi)
                    temp_data = temp_data.reshape(n_species, nphi, ntheta, nr)
                    temp_data = temp_data.transpose(3, 2, 1, 0)  # [nr, ntheta, nphi, n_species]
            else:
                raise ValueError(f"Unknown coordinate system: {coord_system}")
    
    except FileNotFoundError:
        print("Warning: amr_grid.inp not found. Returning raw temperature data.")
    
    return temp_data, grid_info

def check_convergence(current_temp, previous_temp, threshold=0.01, density_weights=None, 
                     return_details=False):
    """
    Check if the temperature solution has converged.
    
    Parameters:
    -----------
    current_temp : ndarray
        Current temperature solution
    previous_temp : ndarray
        Previous temperature solution
    threshold : float
        Convergence threshold for relative difference
    density_weights : ndarray
        Optional density array for weighted convergence check
    return_details : bool
        Whether to return detailed convergence metrics
        
    Returns:
    --------
    bool or dict
        If return_details=False: True if converged, False otherwise
        If return_details=True: Dictionary with convergence metrics
    """
    # Ensure arrays have same shape
    if current_temp.shape != previous_temp.shape:
        raise ValueError(f"Temperature arrays have different shapes: {current_temp.shape} vs {previous_temp.shape}")
    
    # Calculate absolute differences
    abs_diff = np.abs(current_temp - previous_temp)
    
    # Create a mask for non-zero temperatures to avoid division by zero
    valid_mask = previous_temp > 1e-10  # Small epsilon to avoid numerical issues
    
    # Calculate relative differences only for valid cells
    rel_diff = np.zeros_like(abs_diff)
    rel_diff[valid_mask] = abs_diff[valid_mask] / previous_temp[valid_mask]
    
    # If all cells have zero temperature (unlikely but possible), use absolute difference
    if not np.any(valid_mask):
        print("Warning: All cells have near-zero temperature. Using absolute differences.")
        # Use a small value for rel_diff to avoid NaN
        rel_diff = abs_diff / 1.0  # Normalize by 1K as a reference
    
    # Calculate various convergence metrics
    max_diff = np.max(rel_diff)
    mean_diff = np.mean(rel_diff)
    median_diff = np.median(rel_diff)
    p90_diff = np.percentile(rel_diff, 90)
    
    # Calculate density-weighted difference if weights provided
    if density_weights is not None:
        # Ensure density weights have compatible shape
        if density_weights.shape != current_temp.shape[:-1]:  # Ignore species dimension
            # Try to reshape or broadcast
            try:
                weights = np.broadcast_to(density_weights, current_temp.shape[:-1])
            except ValueError:
                print("Warning: Density weights shape incompatible. Using unweighted convergence.")
                weights = None
        else:
            weights = density_weights
        
        if weights is not None:
            # Calculate weighted metrics for each species and take max
            weighted_diff = np.max([np.sum(weights * rel_diff[..., i]) for i in range(current_temp.shape[-1])])
        else:
            weighted_diff = None
    else:
        weighted_diff = None
    
    # Determine convergence
    is_converged = max_diff < threshold
    
    if return_details:
        metrics = {
            'max_diff': max_diff,
            'mean_diff': mean_diff,
            'median_diff': median_diff,
            'p90_diff': p90_diff,
            'weighted_diff': weighted_diff,
            'converged': is_converged
        }
        return metrics
    else:
        return is_converged

def run_radmc3d(cmd='mctherm', params=None, verbose=True, setseed=None):
    """
    Run RADMC-3D with the specified command and parameters.
    
    Parameters:
    -----------
    cmd : str
        RADMC-3D command (e.g., 'mctherm', 'image', 'sed')
    params : dict
        Dictionary of parameters to pass to RADMC-3D
    verbose : bool
        Whether to print RADMC-3D output
    setseed : int
        Random seed for reproducibility
        
    Returns:
    --------
    int
        Return code from RADMC-3D
    """
    # Build command
    command = ['radmc3d']
    
    # Add command
    command.append(cmd)
    
    # Add parameters
    if params:
        for key, value in params.items():
            command.append(f"{key}={value}")
    
    # Add random seed if specified
    if setseed is not None:
        command.append(f"setseed={setseed}")
    
    # Convert command list to string
    command_str = ' '.join(command)
    
    # Print command
    if verbose:
        print(f"Running: {command_str}")
    
    # Run command
    process = subprocess.Popen(command_str, shell=True)
    process.communicate()
    return process.returncode

def read_radmc3d_params(filename='radmc3d.inp'):
    """
    Read the RADMC-3D parameter file and return as a dictionary.
    
    Parameters:
    -----------
    filename : str
        Path to the radmc3d.inp file
        
    Returns:
    --------
    dict
        Dictionary of parameters and their values
    """
    params = {}
    
    if not os.path.exists(filename):
        return params
    
    with open(filename, 'r') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
                
            parts = line.split('=')
            if len(parts) == 2:
                key = parts[0].strip()
                value = parts[1].strip()
                try:
                    # Try to convert to numeric type if possible
                    if '.' in value:
                        params[key] = float(value)
                    else:
                        params[key] = int(value)
                except ValueError:
                    # If conversion fails, keep as string
                    params[key] = value
    
    return params

def plot_temperature_slice(temp_data, grid_info, species=0, slice_dim='z', slice_idx=0, 
                         save_fig=False, filename=None, log_scale=False, title=None,
                         vmin=None, vmax=None):
    """
    Plot a 2D slice of the temperature distribution.
    
    Parameters:
    -----------
    temp_data : ndarray
        Temperature data
    grid_info : dict
        Grid information
    species : int
        Dust species index
    slice_dim : str
        Dimension to slice ('x', 'y', 'z' for Cartesian, 'r', 'theta', 'phi' for spherical)
    slice_idx : int
        Index along slice_dim
    save_fig : bool
        Whether to save the figure
    filename : str
        Filename to save the figure
    log_scale : bool
        Whether to use logarithmic color scale
    title : str
        Plot title
    vmin, vmax : float
        Min and max values for color scale
        
    Returns:
    --------
    fig, ax : matplotlib Figure and Axes
        Figure and axes objects
    """
    import matplotlib.pyplot as plt
    from matplotlib.colors import LogNorm
    
    # Create figure
    fig, ax = plt.subplots(figsize=(10, 8))
    
    # Extract the temperature slice based on grid type
    if grid_info['type'] == 'cartesian':
        # Cartesian grid
        if slice_dim == 'x':
            x_idx = slice_idx
            x_label, y_label = 'y', 'z'
            extent = [grid_info['yi'][0], grid_info['yi'][-1], 
                      grid_info['zi'][0], grid_info['zi'][-1]]
            temp_slice = temp_data[x_idx, :, :, species]
            X, Y = np.meshgrid(grid_info['yc'], grid_info['zc'])
        elif slice_dim == 'y':
            y_idx = slice_idx
            x_label, y_label = 'x', 'z'
            extent = [grid_info['xi'][0], grid_info['xi'][-1], 
                      grid_info['zi'][0], grid_info['zi'][-1]]
            temp_slice = temp_data[:, y_idx, :, species]
            X, Y = np.meshgrid(grid_info['xc'], grid_info['zc'])
        elif slice_dim == 'z':
            z_idx = slice_idx
            x_label, y_label = 'x', 'y'
            extent = [grid_info['xi'][0], grid_info['xi'][-1], 
                      grid_info['yi'][0], grid_info['yi'][-1]]
            temp_slice = temp_data[:, :, z_idx, species]
            X, Y = np.meshgrid(grid_info['xc'], grid_info['yc'])
        else:
            raise ValueError(f"Invalid slice dimension: {slice_dim}")
        
        temp_slice = temp_slice.T  # Transpose for proper orientation
        
    elif grid_info['type'] == 'spherical':
        # Spherical grid - handle both 2D and 3D cases
        if 'nphi' in grid_info and grid_info['nphi'] > 1:
            # 3D spherical grid
            if slice_dim == 'r':
                r_idx = slice_idx
                x_label, y_label = 'θ', 'φ'
                extent = [grid_info['thetai'][0], grid_info['thetai'][-1], 
                          grid_info['phii'][0], grid_info['phii'][-1]]
                temp_slice = temp_data[r_idx, :, :, species]
                X, Y = np.meshgrid(grid_info['thetac'], grid_info['phic'])
            elif slice_dim == 'theta':
                theta_idx = slice_idx
                x_label, y_label = 'r', 'φ'
                extent = [grid_info['ri'][0], grid_info['ri'][-1], 
                          grid_info['phii'][0], grid_info['phii'][-1]]
                temp_slice = temp_data[:, theta_idx, :, species]
                X, Y = np.meshgrid(grid_info['rc'], grid_info['phic'])
            elif slice_dim == 'phi':
                phi_idx = slice_idx
                x_label, y_label = 'r', 'θ'
                extent = [grid_info['ri'][0], grid_info['ri'][-1], 
                          grid_info['thetai'][0], grid_info['thetai'][-1]]
                temp_slice = temp_data[:, :, phi_idx, species]
                X, Y = np.meshgrid(grid_info['rc'], grid_info['thetac'])
            else:
                raise ValueError(f"Invalid slice dimension: {slice_dim}")
            
            temp_slice = temp_slice.T  # Transpose for proper orientation
        else:
            # 2D spherical grid (r, theta) - common for water fountain models
            x_label, y_label = 'r', 'θ'
            extent = [grid_info['ri'][0], grid_info['ri'][-1], 
                      grid_info['thetai'][0], grid_info['thetai'][-1]]
            temp_slice = temp_data[:, :, species]
            X, Y = np.meshgrid(grid_info['rc'], grid_info['thetac'])
            temp_slice = temp_slice.T  # Transpose for proper orientation
    else:
        raise ValueError(f"Unknown grid type: {grid_info['type']}")
    
    # Plot the temperature slice
    if log_scale:
        im = ax.pcolormesh(X, Y, temp_slice, norm=LogNorm(vmin=vmin, vmax=vmax), cmap='inferno', shading='auto')
    else:
        im = ax.pcolormesh(X, Y, temp_slice, vmin=vmin, vmax=vmax, cmap='inferno', shading='auto')
    
    # Set axis labels and title
    ax.set_xlabel(f'{x_label} [cm]')
    ax.set_ylabel(f'{y_label} [cm]')
    
    if title:
        ax.set_title(title)
    else:
        ax.set_title(f'Dust Temperature [K], {slice_dim}={slice_idx}')
    
    # Add colorbar
    cbar = fig.colorbar(im, ax=ax)
    cbar.set_label('Temperature [K]')
    
    # Save figure if requested
    if save_fig:
        if filename:
            plt.savefig(filename, dpi=150, bbox_inches='tight')
        else:
            plt.savefig(f'temperature_{slice_dim}{slice_idx}.png', dpi=150, bbox_inches='tight')
    
    return fig, ax

def compare_temperature_slices(temp_data1, temp_data2, grid_info, species=0, slice_dim='z', 
                               slice_idx=0, save_fig=False, filename=None, titles=None,
                               show_fig=False):
    """
    Compare two temperature fields side by side and show their difference.
    
    Parameters:
    -----------
    temp_data1, temp_data2 : ndarray
        Temperature data arrays to compare. Can be 3D [nr, ntheta, nspec] or 4D [nr, ntheta, nphi, nspec]
    grid_info : dict
        Grid information
    species : int
        Dust species index
    slice_dim : str
        Dimension to slice ('x', 'y', 'z' for Cartesian or 'phi' for spherical)
    slice_idx : int
        Index along the slice dimension
    save_fig : bool
        Whether to save the figure
    filename : str
        Output filename if save_fig is True
    titles : list
        Custom titles for the plots [title1, title2, diff_title]
    show_fig : bool
        Whether to display the figure (default: False)
    """
    # Check if we're dealing with a spherical grid
    is_spherical = grid_info.get('type', 'cartesian').lower() == 'spherical'
    
    # Check dimensionality of temperature arrays
    is_3d_temp = len(temp_data1.shape) == 3  # [nr, ntheta, nspec]
    is_4d_temp = len(temp_data1.shape) == 4  # [nr, ntheta, nphi, nspec]
    
    # Make sure both arrays have the same dimensionality
    if len(temp_data1.shape) != len(temp_data2.shape):
        print(f"Warning: Temperature arrays have different dimensions: {temp_data1.shape} vs {temp_data2.shape}")
        return
    
    # Extract slices based on grid type and dimensionality
    if is_spherical:
        if is_3d_temp:  # 2D spherical grid (r, theta) with species
            # For 2D spherical grid, we don't need to slice along phi
            slice1 = temp_data1[:, :, species]
            if temp_data2.shape == temp_data1.shape:
                slice2 = temp_data2[:, :, species]
                xlabel, ylabel = 'r', 'theta'
            else:
                print(f"Warning: Temperature arrays have different shapes: {temp_data1.shape} vs {temp_data2.shape}")
                return
        elif is_4d_temp:  # 3D spherical grid (r, theta, phi) with species
            # For 3D spherical grid, we slice along phi
            if slice_dim == 'phi' or slice_dim == 'z':
                if slice_idx >= temp_data1.shape[2]:
                    slice_idx = 0  # Default to first phi slice if index is out of bounds
                
                slice1 = temp_data1[:, :, slice_idx, species]
                if temp_data2.shape == temp_data1.shape:
                    slice2 = temp_data2[:, :, slice_idx, species]
                    xlabel, ylabel = 'r', 'theta'
                else:
                    print(f"Warning: Temperature arrays have different shapes: {temp_data1.shape} vs {temp_data2.shape}")
                    return
            else:
                print(f"Warning: Slice dimension '{slice_dim}' not supported for spherical grid. Using phi=0 slice.")
                slice1 = temp_data1[:, :, 0, species]
                if temp_data2.shape == temp_data1.shape:
                    slice2 = temp_data2[:, :, 0, species]
                    xlabel, ylabel = 'r', 'theta'
                else:
                    print(f"Warning: Temperature arrays have different shapes: {temp_data1.shape} vs {temp_data2.shape}")
                    return
        else:
            print(f"Warning: Unexpected temperature array shape: {temp_data1.shape}")
            return
    else:  # Cartesian grid
        if is_4d_temp:  # 3D Cartesian grid (x, y, z) with species
            if slice_dim == 'z':
                if slice_idx >= temp_data1.shape[2]:
                    slice_idx = 0
                slice1 = temp_data1[:, :, slice_idx, species]
                if temp_data2.shape == temp_data1.shape:
                    slice2 = temp_data2[:, :, slice_idx, species]
                    xlabel, ylabel = 'x', 'y'
                else:
                    print(f"Warning: Temperature arrays have different shapes: {temp_data1.shape} vs {temp_data2.shape}")
                    return
            elif slice_dim == 'y':
                if slice_idx >= temp_data1.shape[1]:
                    slice_idx = 0
                slice1 = temp_data1[:, slice_idx, :, species]
                if temp_data2.shape == temp_data1.shape:
                    slice2 = temp_data2[:, slice_idx, :, species]
                    xlabel, ylabel = 'x', 'z'
                else:
                    print(f"Warning: Temperature arrays have different shapes: {temp_data1.shape} vs {temp_data2.shape}")
                    return
            elif slice_dim == 'x':
                if slice_idx >= temp_data1.shape[0]:
                    slice_idx = 0
                slice1 = temp_data1[slice_idx, :, :, species]
                if temp_data2.shape == temp_data1.shape:
                    slice2 = temp_data2[slice_idx, :, :, species]
                    xlabel, ylabel = 'y', 'z'
                else:
                    print(f"Warning: Temperature arrays have different shapes: {temp_data1.shape} vs {temp_data2.shape}")
                    return
            else:
                print(f"Warning: Slice dimension '{slice_dim}' not supported. Using z slice.")
                slice1 = temp_data1[:, :, 0, species]
                if temp_data2.shape == temp_data1.shape:
                    slice2 = temp_data2[:, :, 0, species]
                    xlabel, ylabel = 'x', 'y'
                else:
                    print(f"Warning: Temperature arrays have different shapes: {temp_data1.shape} vs {temp_data2.shape}")
                    return
        elif is_3d_temp:  # 2D Cartesian grid (x, y) with species
            slice1 = temp_data1[:, :, species]
            if temp_data2.shape == temp_data1.shape:
                slice2 = temp_data2[:, :, species]
                xlabel, ylabel = 'x', 'y'
            else:
                print(f"Warning: Temperature arrays have different shapes: {temp_data1.shape} vs {temp_data2.shape}")
                return
        else:
            print(f"Warning: Unexpected temperature array shape: {temp_data1.shape}")
            return
    
    # Calculate relative difference with protection against division by zero
    valid_mask = slice1 > 1e-10  # Small epsilon to avoid numerical issues
    rel_diff = np.zeros_like(slice1)
    rel_diff[valid_mask] = np.abs(slice2[valid_mask] - slice1[valid_mask]) / slice1[valid_mask]
    
    # Create figure with 3 subplots
    fig, axes = plt.subplots(1, 3, figsize=(18, 6))
    
    # Plot first temperature field
    im1 = axes[0].imshow(slice1, origin='lower', interpolation='nearest', cmap='inferno')
    plt.colorbar(im1, ax=axes[0], label='Temperature [K]')
    axes[0].set_xlabel(xlabel)
    axes[0].set_ylabel(ylabel)
    if titles and len(titles) > 0:
        axes[0].set_title(titles[0])
    else:
        axes[0].set_title(f'Temperature 1')
    
    # Plot second temperature field
    im2 = axes[1].imshow(slice2, origin='lower', interpolation='nearest', cmap='inferno')
    plt.colorbar(im2, ax=axes[1], label='Temperature [K]')
    axes[1].set_xlabel(xlabel)
    axes[1].set_ylabel(ylabel)
    if titles and len(titles) > 1:
        axes[1].set_title(titles[1])
    else:
        axes[1].set_title(f'Temperature 2')
    
    # Plot relative difference
    max_diff = np.max(rel_diff)
    im3 = axes[2].imshow(rel_diff, origin='lower', interpolation='nearest', 
                         cmap='viridis', vmin=0, vmax=min(1.0, max_diff*1.2 if max_diff > 0 else 1.0))
    plt.colorbar(im3, ax=axes[2], label='Relative Difference')
    axes[2].set_xlabel(xlabel)
    axes[2].set_ylabel(ylabel)
    if titles and len(titles) > 2:
        axes[2].set_title(titles[2])
    else:
        axes[2].set_title('Relative Difference')
    
    plt.tight_layout()
    
    if save_fig and filename:
        plt.savefig(filename, dpi=300, bbox_inches='tight')
    
    if show_fig:
        plt.show()
    else:
        plt.close(fig)

def save_temperature_history(temp_history, filename='temperature_history.npy'):
    """
    Save the temperature history to a NumPy file.
    
    Parameters:
    -----------
    temp_history : list
        List of temperature data arrays
    filename : str
        Output filename
    """
    np.save(filename, temp_history)

def load_temperature_history(filename='temperature_history.npy'):
    """
    Load the temperature history from a NumPy file.
    
    Parameters:
    -----------
    filename : str
        Input filename
        
    Returns:
    --------
    list
        List of temperature data arrays
    """
    return np.load(filename, allow_pickle=True)

def plot_convergence_history(metrics_history, nphotons_history, save_fig=False, filename=None,
                             metrics_to_plot=None, threshold=0.01, show_fig=False):
    """
    Plot the convergence history with multiple metrics.
    
    Parameters:
    -----------
    metrics_history : list of dict
        List of metrics dictionaries for each iteration
    nphotons_history : list
        List of number of photons used
    save_fig : bool
        Whether to save the figure
    filename : str
        Output filename if save_fig is True
    metrics_to_plot : list
        List of metric names to plot (default: all available)
    threshold : float
        Convergence threshold to plot as horizontal line
    show_fig : bool
        Whether to display the figure (default: False)
    """
    if not metrics_history:
        print("No metrics to plot")
        return
    
    # If metrics_history contains only floats (max_diff), convert to dict format
    if isinstance(metrics_history[0], (int, float)):
        metrics_history = [{'max_diff': diff} for diff in metrics_history]
    
    # Get all available metrics if not specified
    if metrics_to_plot is None:
        metrics_to_plot = metrics_history[0].keys()
    
    fig = plt.figure(figsize=(12, 8))
    
    for metric in metrics_to_plot:
        if metric in metrics_history[0]:
            # Extract metric values, skipping None values
            values = [m.get(metric) for m in metrics_history if m.get(metric) is not None]
            
            # Only plot if we have values
            if values:
                plt.loglog(nphotons_history[:len(values)], values, 'o-', linewidth=2, label=metric)
    
    # Plot threshold line
    plt.axhline(y=threshold, color='red', linestyle='--', alpha=0.7, label=f'Threshold ({threshold})')
    
    plt.xlabel('Number of photons')
    plt.ylabel('Relative difference')
    plt.grid(True, which='both', linestyle='--', alpha=0.7)
    plt.title('Convergence History')
    plt.legend()
    
    if save_fig and filename:
        plt.savefig(filename, dpi=300, bbox_inches='tight')
    
    if show_fig:
        plt.show()
    else:
        plt.close(fig)

def analyze_temperature_distribution(temp_data, grid_info, species=0, bins=50, 
                                    save_fig=False, filename=None, show_fig=False):
    """
    Analyze and plot the distribution of temperatures in the model.
    
    Parameters:
    -----------
    temp_data : ndarray
        Temperature data from read_dust_temperature()
    grid_info : dict
        Grid information
    species : int
        Dust species index
    bins : int
        Number of histogram bins
    save_fig : bool
        Whether to save the figure
    filename : str
        Output filename if save_fig is True
    show_fig : bool
        Whether to display the figure (default: False)
        
    Returns:
    --------
    dict
        Dictionary with temperature statistics
    """
    # Extract temperatures for the specified species
    if len(temp_data.shape) == 3:  # [nr, ntheta, nspec]
        temps = temp_data[:, :, species].flatten()
    elif len(temp_data.shape) == 4:  # [nr, ntheta, nphi, nspec]
        temps = temp_data[:, :, :, species].flatten()
    else:
        print(f"Warning: Unexpected temperature array shape: {temp_data.shape}")
        return None
    
    # Create figure
    fig = plt.figure(figsize=(10, 6))
    
    # Plot histogram
    n, bins, patches = plt.hist(temps, bins=bins, alpha=0.7, color='navy')
    
    # Add vertical lines for statistics
    plt.axvline(np.min(temps), color='red', linestyle='--', label=f'Min: {np.min(temps):.1f} K')
    plt.axvline(np.max(temps), color='green', linestyle='--', label=f'Max: {np.max(temps):.1f} K')
    plt.axvline(np.mean(temps), color='orange', linestyle='-', label=f'Mean: {np.mean(temps):.1f} K')
    plt.axvline(np.median(temps), color='purple', linestyle='-', label=f'Median: {np.median(temps):.1f} K')
    
    plt.xlabel('Temperature [K]')
    plt.ylabel('Number of cells')
    plt.title(f'Temperature Distribution (species {species})')
    plt.legend()
    plt.grid(True, alpha=0.3)
    
    if save_fig and filename:
        plt.savefig(filename, dpi=300, bbox_inches='tight')
    
    if show_fig:
        plt.show()
    else:
        plt.close(fig)
    
    # Return some statistics
    stats = {
        'min': np.min(temps),
        'max': np.max(temps),
        'mean': np.mean(temps),
        'median': np.median(temps),
        'std': np.std(temps),
        'p10': np.percentile(temps, 10),
        'p90': np.percentile(temps, 90)
    }
    
    return stats

def plot_advanced_temperature_density(grid_info=None, temp_data=None, density_data=None, 
                                 output_dir='figures', species=0, slice_phi=0,
                                 temp_contours=20, save_fig=True, show_fig=False,
                                 iteration=None):
    """
    Create enhanced visualizations of dust temperature and density.
    
    Parameters:
    -----------
    grid_info : dict
        Grid information dictionary
    temp_data : ndarray
        Temperature data from read_dust_temperature()
    density_data : ndarray
        Density data from read_dust_density()
    output_dir : str
        Directory to save figures
    species : int
        Dust species index
    slice_phi : int
        Phi index for 2D slices
    temp_contours : int or list
        Number of contour levels or list of specific levels
    save_fig : bool
        Whether to save figures
    show_fig : bool
        Whether to show figures interactively
    iteration : int, optional
        Iteration number to include in plot titles
        
    Returns:
    --------
    dict
        Dictionary with temperature statistics
    """
    import matplotlib.pyplot as plt
    import numpy as np
    import os
    from matplotlib.colors import LogNorm, BoundaryNorm
    
    # Create output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)
    
    # Read data if not provided
    if grid_info is None:
        if os.path.exists('amr_grid.inp'):
            _, grid_info = read_dust_temperature()
        else:
            raise ValueError("Grid information is required but amr_grid.inp not found")
    
    if temp_data is None:
        if os.path.exists('dust_temperature.dat'):
            temp_data, _ = read_dust_temperature()
        else:
            raise ValueError("Temperature data is required but dust_temperature.dat not found")
    
    if density_data is None:
        if os.path.exists('dust_density.inp'):
            try:
                density_data, _, _, _ = read_dust_density(grid_info=grid_info)
            except Exception as e:
                print(f"Warning: Could not read density data: {e}")
                density_data = None
        else:
            print("Warning: dust_density.inp not found, skipping density plots")
    
    # Print data shapes for debugging
    print(f"Temperature data shape: {temp_data.shape}")
    if density_data is not None:
        print(f"Density data shape: {density_data.shape}")
    
    # Extract grid coordinates
    if grid_info['type'] == 'spherical':
        # For spherical coordinates
        r = grid_info['ri']  # Cell boundaries for r
        theta = grid_info['thetai']  # Cell boundaries for theta
        phi = grid_info['phii'] if 'phii' in grid_info else None  # Cell boundaries for phi
        
        # Create meshgrid for plotting
        R, Theta = np.meshgrid(r, theta)
        X = R * np.sin(Theta)
        Y = R * np.cos(Theta)
        
        # Get cell centers for plotting
        r_centers = grid_info['rc']  # Cell centers for r
        theta_centers = grid_info['thetac']  # Cell centers for theta
        R_centers, Theta_centers = np.meshgrid(r_centers, theta_centers)
        X_centers = R_centers * np.sin(Theta_centers)
        Y_centers = R_centers * np.cos(Theta_centers)
        
        # Handle indexing for slicing based on dimensionality
        if len(temp_data.shape) == 3:  # 2D case (r, theta, species)
            # For 2D data, we need to transpose to get (theta, r) for plotting
            temp_slice = temp_data[:, :, species].T
            if density_data is not None and len(density_data.shape) == 3:
                density_slice = density_data[:, :, species].T
            else:
                density_data = None
        elif len(temp_data.shape) == 4:  # 3D case (r, theta, phi, species)
            # For 3D data, we need to select a phi slice and transpose
            temp_slice = temp_data[:, :, slice_phi, species].T
            if density_data is not None and len(density_data.shape) == 4:
                density_slice = density_data[:, :, slice_phi, species].T
            else:
                density_data = None
        else:
            raise ValueError(f"Unexpected temperature data shape: {temp_data.shape}")
    
    elif grid_info['type'] == 'cartesian':
        # For cartesian coordinates - adjust as needed
        raise NotImplementedError("Cartesian coordinates not yet implemented for advanced plots")
    else:
        raise ValueError(f"Unknown grid type: {grid_info['type']}")
    
    # 1. Plot density if available
    if density_data is not None:
        plt.figure(figsize=(10, 8))
        im = plt.pcolormesh(X/1e15, Y/1e15, 
                           np.log10(density_slice),
                           shading='auto')
        plt.colorbar(im, label='log₁₀(density) [g/cm³]')
        plt.axis('equal')
        plt.xlabel('R [1000 AU]')
        plt.ylabel('z [1000 AU]')
        
        if iteration is not None:
            plt.title(f'Log Dust Density - Iteration {iteration} (R-z plane)')
        else:
            plt.title(f'Log Dust Density (R-z plane)')
            
        if save_fig:
            plt.savefig(os.path.join(output_dir, 'dust_density.png'), dpi=300)
        if not show_fig:
            plt.close()
    
    # 2. Plot temperature (standard)
    plt.figure(figsize=(10, 8))
    im = plt.pcolormesh(X/1e15, Y/1e15, 
                       temp_slice,
                       cmap='inferno', shading='auto')
    plt.colorbar(im, label='Temperature [K]')
    plt.axis('equal')
    plt.xlabel('R [1000 AU]')
    plt.ylabel('z [1000 AU]')
    
    if iteration is not None:
        plt.title(f'Dust Temperature - Iteration {iteration} (R-z plane)')
    else:
        plt.title(f'Dust Temperature (R-z plane)')
        
    if save_fig:
        plt.savefig(os.path.join(output_dir, 'dust_temperature.png'), dpi=300)
    if not show_fig:
        plt.close()
    
    # 3. Create temperature zone map with contours
    plt.figure(figsize=(12, 10))
    
    # Define colors for temperature zones
    max_temp = np.max(temp_slice)
    cmap = plt.cm.colors.ListedColormap(['#3498db', '#2ecc71', '#f39c12', '#e74c3c'])
    bounds = [0, 50, 150, 250, max(300, np.max(temp_slice))]
    norm = BoundaryNorm(bounds, cmap.N)
    
    # Create the main color zone plot
    im = plt.pcolormesh(X_centers/1e15, Y_centers/1e15, 
                       temp_slice,
                       cmap=cmap, norm=norm, shading='auto')
    
    # Add contour lines
    if isinstance(temp_contours, int):
        contour_levels = np.linspace(0, np.max(temp_slice), temp_contours)
    else:
        contour_levels = temp_contours
        
    contours = plt.contour(X_centers/1e15, Y_centers/1e15, temp_slice, 
                         levels=contour_levels, colors='black', alpha=0.5, linewidths=0.5)
    plt.clabel(contours, inline=True, fontsize=8, fmt='%.0f')
    
    # Add colorbar
    ticks = [25, min(100, max_temp/2), min(200, max_temp*0.75), min(max_temp*0.9, 300)]
    cbar = plt.colorbar(im, ticks=ticks)
    cbar.set_label('Temperature [K]')
    cbar.ax.set_yticklabels(['<50K', '50-150K', '150-250K', '>250K'])
    
    plt.axis('equal')
    plt.xlabel('R [1000 AU]')
    plt.ylabel('z [1000 AU]')
    
    if iteration is not None:
        plt.title(f'Dust Temperature Zones with Contours - Iteration {iteration} (R-z plane)')
    else:
        plt.title(f'Dust Temperature Zones with Contours (R-z plane)')
    
    if save_fig:
        plt.savefig(os.path.join(output_dir, 'temperature_zones_map.png'), dpi=300)
    if not show_fig:
        plt.close()
    
    # 4. Analyze temperature distribution
    # Flatten the temperature array for the specified dust species
    if len(temp_data.shape) == 3:  # 2D case (r, theta, species)
        temp_flat = temp_data[:, :, species].flatten()
    elif len(temp_data.shape) == 4:  # 3D case (r, theta, phi, species)
        temp_flat = temp_data[:, :, :, species].flatten()
    else:
        raise ValueError(f"Unexpected temperature data shape: {temp_data.shape}")
    
    # Count cells in different temperature ranges
    below_50K = np.sum(temp_flat < 50)
    between_50_150K = np.sum((temp_flat >= 50) & (temp_flat < 150))
    between_150_250K = np.sum((temp_flat >= 150) & (temp_flat < 250))
    above_250K = np.sum(temp_flat >= 250)
    
    # Print the counts and percentages
    total_cells = len(temp_flat)
    print(f"\nTemperature distribution for dust species {species}:")
    print(f"Below 50K: {below_50K} cells ({below_50K/total_cells*100:.1f}%)")
    print(f"50K-150K: {between_50_150K} cells ({between_50_150K/total_cells*100:.1f}%)")
    print(f"150K-250K: {between_150_250K} cells ({between_150_250K/total_cells*100:.1f}%)")
    print(f"Above 250K: {above_250K} cells ({above_250K/total_cells*100:.1f}%)")
    
    # 5. Create histogram of temperature distribution
    plt.figure(figsize=(10, 6))
    hist_bins = np.linspace(0, max(500, np.max(temp_flat)), 100)
    plt.hist(temp_flat, bins=hist_bins, alpha=0.7, color='orange')
    plt.axvline(50, color='r', linestyle='--', alpha=0.7, label='50K')
    plt.axvline(150, color='g', linestyle='--', alpha=0.7, label='150K')
    plt.axvline(250, color='b', linestyle='--', alpha=0.7, label='250K')
    plt.xlabel('Temperature [K]')
    plt.ylabel('Number of Cells')
    plt.title(f'Dust Temperature Distribution (species={species})')
    plt.legend()
    plt.grid(alpha=0.3)
    if save_fig:
        plt.savefig(os.path.join(output_dir, 'temperature_histogram.png'), dpi=300)
    if not show_fig:
        plt.close()
    
    # 6. Create pie chart of temperature distribution
    plt.figure(figsize=(8, 8))
    labels = ['<50K', '50K-150K', '150K-250K', '>250K']
    sizes = [below_50K, between_50_150K, between_150_250K, above_250K]
    colors = ['#3498db', '#2ecc71', '#f39c12', '#e74c3c']
    plt.pie(sizes, labels=labels, colors=colors, autopct='%1.1f%%', startangle=90)
    plt.axis('equal')
    plt.title('Temperature Distribution by Range')
    if save_fig:
        plt.savefig(os.path.join(output_dir, 'temperature_distribution_pie.png'), dpi=300)
    if not show_fig:
        plt.close()
    
    # Return statistics
    stats = {
        'below_50K': below_50K,
        'between_50_150K': between_50_150K,
        'between_150_250K': between_150_250K,
        'above_250K': above_250K,
        'total_cells': total_cells,
        'max_temperature': np.max(temp_flat),
        'min_temperature': np.min(temp_flat),
        'mean_temperature': np.mean(temp_flat),
        'median_temperature': np.median(temp_flat)
    }
    
    return stats

def read_dust_density(filename='dust_density.inp', grid_info=None):
    """
    Read dust density data from RADMC-3D output file.
    
    Parameters:
    -----------
    filename : str
        Name of the dust density file
    grid_info : dict, optional
        Grid information dictionary. If not provided, will try to read from amr_grid.inp
        
    Returns:
    --------
    ndarray
        Dust density array with shape [nr, ntheta, nphi, nspec] or [nr, ntheta, nspec]
    dict
        Grid information dictionary
    int
        Number of cells
    int
        Number of species
    """
    import numpy as np
    import os
    
    # If grid_info not provided, try to read it
    if grid_info is None:
        if os.path.exists('amr_grid.inp'):
            _, grid_info = read_dust_temperature(filename='dust_temperature.dat')
        else:
            raise ValueError("Grid information must be provided or amr_grid.inp must exist")
    
    # Extract grid dimensions based on grid type
    if grid_info['type'] == 'spherical':
        nr = grid_info['nr']
        ntheta = grid_info['ntheta']
        nphi = grid_info.get('nphi', 1)  # Default to 1 if not present (2D case)
    elif grid_info['type'] == 'cartesian':
        nr = grid_info['nx']
        ntheta = grid_info['ny']
        nphi = grid_info['nz']
    else:
        raise ValueError(f"Unknown grid type: {grid_info['type']}")
    
    # Total number of cells
    ncells = nr * ntheta * nphi
    
    try:
        with open(filename, 'r') as f:
            # Read the header
            iformat = int(f.readline().strip())
            nrcells = int(f.readline().strip())
            nrspec = int(f.readline().strip())
            
            # Verify cell count matches grid
            if nrcells != ncells:
                print(f"Warning: Cell count mismatch. File has {nrcells}, grid has {ncells}")
            
            # Read densities for each species
            densities = []
            for ispec in range(nrspec):
                species_density = []
                for _ in range(nrcells):
                    species_density.append(float(f.readline().strip()))
                densities.append(np.array(species_density))
        
        # Convert to numpy array
        densities = np.array(densities)  # Shape: [nrspec, nrcells]
        
        # Reshape based on grid type and dimensionality
        if grid_info['type'] == 'spherical':
            if nphi == 1:
                # 2D case (r, theta)
                densities = densities.reshape(nrspec, ntheta, nr)
                # Transpose to get [nr, ntheta, nrspec]
                densities = densities.transpose(2, 1, 0)
            else:
                # 3D case (r, theta, phi)
                densities = densities.reshape(nrspec, nphi, ntheta, nr)
                # Transpose to get [nr, ntheta, nphi, nrspec]
                densities = densities.transpose(3, 2, 1, 0)
        else:
            # Cartesian case
            densities = densities.reshape(nrspec, nphi, ntheta, nr)
            # Transpose to get [nr, ntheta, nphi, nrspec]
            densities = densities.transpose(3, 2, 1, 0)
        
        return densities, grid_info, nrcells, nrspec
        
    except Exception as e:
        raise Exception(f"Error reading dust density file: {e}") 