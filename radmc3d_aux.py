import numpy as np
import os
import subprocess
import matplotlib.pyplot as plt
from matplotlib.colors import LogNorm, BoundaryNorm
# Import physical constants from create_input
from create_input import au, Rsun, Msun, G, sigma, c, h, kB

def read_dust_temperature(filename='dust_temperature.dat'):
    """
    Read the dust temperature file generated by RADMC-3D.
    
    Parameters:
    -----------
    filename : str
        Path to the dust temperature file
        
    Returns:
    --------
    temp_data : ndarray
        Array containing dust temperature data with shape [nr, ntheta, nphi, nspec] or [nr, ntheta, nspec]
    grid_info : dict
        Dictionary containing grid information
    """
    # Read dust temperature data
    with open(filename, 'r') as f:
        iformat = int(f.readline().strip())
        if iformat != 1:
            raise ValueError(f"Unknown file format: {iformat}")
        
        n_cells = int(f.readline().strip())
        n_species = int(f.readline().strip())
        
        # Read temperature data for each cell and species
        temp_data = []
        for i in range(n_species):
            species_temp = []
            for j in range(n_cells):
                species_temp.append(float(f.readline().strip()))
            temp_data.append(np.array(species_temp))
        
        # Convert to numpy array
        temp_data = np.array(temp_data)  # Shape: [n_species, n_cells]
    
    # Read the grid file to get grid information
    try:
        with open('amr_grid.inp', 'r') as f:
            iformat = int(f.readline().strip())
            grid_style = int(f.readline().strip())
            coord_system = int(f.readline().strip())
            grid_info_flag = int(f.readline().strip())
            include_coords = [int(x) for x in f.readline().strip().split()]
            grid_dims = [int(x) for x in f.readline().strip().split()]
            
            # Create grid info dictionary
            grid_info = {}
            
            if coord_system == 0:  # Cartesian
                grid_info['type'] = 'cartesian'
                grid_info['nx'], grid_info['ny'], grid_info['nz'] = grid_dims
                
                # Read cell boundaries
                xi = np.array([float(f.readline().strip()) for _ in range(grid_info['nx'] + 1)])
                yi = np.array([float(f.readline().strip()) for _ in range(grid_info['ny'] + 1)])
                zi = np.array([float(f.readline().strip()) for _ in range(grid_info['nz'] + 1)])
                
                # Calculate cell centers
                xc = 0.5 * (xi[:-1] + xi[1:])
                yc = 0.5 * (yi[:-1] + yi[1:])
                zc = 0.5 * (zi[:-1] + zi[1:])
                
                grid_info['xi'] = xi
                grid_info['yi'] = yi
                grid_info['zi'] = zi
                grid_info['xc'] = xc
                grid_info['yc'] = yc
                grid_info['zc'] = zc
                
                # Reshape temperature data to 3D grid
                nr = grid_info['nx']
                ntheta = grid_info['ny']
                nphi = grid_info['nz']
                
                # Reshape and transpose to match density format
                temp_data = temp_data.reshape(n_species, nphi, ntheta, nr)
                temp_data = temp_data.transpose(3, 2, 1, 0)  # [nr, ntheta, nphi, n_species]
                
            elif coord_system == 100:  # Spherical
                grid_info['type'] = 'spherical'
                grid_info['nr'], grid_info['ntheta'], grid_info['nphi'] = grid_dims
                
                # Read cell boundaries
                ri = np.array([float(f.readline().strip()) for _ in range(grid_info['nr'] + 1)])
                thetai = np.array([float(f.readline().strip()) for _ in range(grid_info['ntheta'] + 1)])
                phii = np.array([float(f.readline().strip()) for _ in range(grid_info['nphi'] + 1)])
                
                # Calculate cell centers
                rc = 0.5 * (ri[:-1] + ri[1:])
                thetac = 0.5 * (thetai[:-1] + thetai[1:])
                phic = 0.5 * (phii[:-1] + phii[1:])
                
                grid_info['ri'] = ri
                grid_info['thetai'] = thetai
                grid_info['phii'] = phii
                grid_info['rc'] = rc
                grid_info['thetac'] = thetac
                grid_info['phic'] = phic
                
                # Reshape temperature data based on dimensionality
                nr = grid_info['nr']
                ntheta = grid_info['ntheta']
                nphi = grid_info['nphi']
                
                if nphi == 1:
                    # 2D case (r, theta)
                    temp_data = temp_data.reshape(n_species, ntheta, nr)
                    temp_data = temp_data.transpose(2, 1, 0)  # [nr, ntheta, n_species]
                else:
                    # 3D case (r, theta, phi)
                    temp_data = temp_data.reshape(n_species, nphi, ntheta, nr)
                    temp_data = temp_data.transpose(3, 2, 1, 0)  # [nr, ntheta, nphi, n_species]
            else:
                raise ValueError(f"Unknown coordinate system: {coord_system}")
    
    except FileNotFoundError:
        print("Warning: amr_grid.inp not found. Returning raw temperature data.")
    
    return temp_data, grid_info

def check_convergence(current_temp, previous_temp, threshold=0.01, density_weights=None, 
                     return_details=False):
    """
    Check if the temperature solution has converged.
    
    Parameters:
    -----------
    current_temp : ndarray
        Current temperature solution
    previous_temp : ndarray
        Previous temperature solution
    threshold : float
        Convergence threshold for relative difference
    density_weights : ndarray
        Optional density array for weighted convergence check
    return_details : bool
        Whether to return detailed convergence metrics
        
    Returns:
    --------
    bool or dict
        If return_details=False: True if converged, False otherwise
        If return_details=True: Dictionary with convergence metrics
    """
    # Handle arrays with different shapes (e.g., transitioning from single to multi-species)
    if current_temp.shape != previous_temp.shape:
        print(f"Warning: Temperature arrays have different shapes: {current_temp.shape} vs {previous_temp.shape}")
        print("Adapting arrays for convergence check...")
        
        # Case 1: Different number of species
        if len(current_temp.shape) == len(previous_temp.shape) and current_temp.shape[:-1] == previous_temp.shape[:-1]:
            if current_temp.shape[-1] > previous_temp.shape[-1]:
                # Current has more species than previous
                print(f"Using first species from current temperature ({current_temp.shape[-1]} species)")
                if len(current_temp.shape) == 3:  # 2D case
                    current_temp_adapted = current_temp[:, :, 0:1]  # Keep dimension
                elif len(current_temp.shape) == 4:  # 3D case
                    current_temp_adapted = current_temp[:, :, :, 0:1]
                else:
                    raise ValueError(f"Unexpected temperature array dimensionality: {len(current_temp.shape)}")
                previous_temp_adapted = previous_temp
            else:
                # Previous has more species than current
                print(f"Using first species from previous temperature ({previous_temp.shape[-1]} species)")
                current_temp_adapted = current_temp
                if len(previous_temp.shape) == 3:  # 2D case
                    previous_temp_adapted = previous_temp[:, :, 0:1]
                elif len(previous_temp.shape) == 4:  # 3D case
                    previous_temp_adapted = previous_temp[:, :, :, 0:1]
                else:
                    raise ValueError(f"Unexpected temperature array dimensionality: {len(previous_temp.shape)}")
        else:
            # Other shape mismatches - try a more general approach
            print("Using averaged temperature for comparison")
            
            # Average over species dimension if present
            if len(current_temp.shape) >= 3:
                current_temp_adapted = np.mean(current_temp, axis=-1)
            else:
                current_temp_adapted = current_temp
                
            if len(previous_temp.shape) >= 3:
                previous_temp_adapted = np.mean(previous_temp, axis=-1)
            else:
                previous_temp_adapted = previous_temp
                
            # Ensure arrays have same shape for comparison
            if current_temp_adapted.shape != previous_temp_adapted.shape:
                raise ValueError(f"Cannot adapt temperature arrays with shapes {current_temp.shape} and {previous_temp.shape} for comparison")
    else:
        # Same shape, no adaptation needed
        current_temp_adapted = current_temp
        previous_temp_adapted = previous_temp
    
    # Calculate absolute differences
    abs_diff = np.abs(current_temp_adapted - previous_temp_adapted)
    
    # Create a mask for non-zero temperatures to avoid division by zero
    valid_mask = previous_temp_adapted > 1e-10  # Small epsilon to avoid numerical issues
    
    # Calculate relative differences only for valid cells
    rel_diff = np.zeros_like(abs_diff)
    rel_diff[valid_mask] = abs_diff[valid_mask] / previous_temp_adapted[valid_mask]
    
    # If all cells have zero temperature (unlikely but possible), use absolute difference
    if not np.any(valid_mask):
        print("Warning: All cells have near-zero temperature. Using absolute differences.")
        # Use a small value for rel_diff to avoid NaN
        rel_diff = abs_diff / 1.0  # Normalize by 1K as a reference
    
    # Calculate various convergence metrics
    max_diff = np.max(rel_diff)
    mean_diff = np.mean(rel_diff)
    median_diff = np.median(rel_diff)
    p90_diff = np.percentile(rel_diff, 90)
    
    # Calculate density-weighted difference if weights provided
    if density_weights is not None:
        # Ensure density weights have compatible shape
        if density_weights.shape != current_temp_adapted.shape[:-1]:  # Ignore species dimension
            # Try to reshape or broadcast
            try:
                weights = np.broadcast_to(density_weights, current_temp_adapted.shape[:-1])
            except ValueError:
                print("Warning: Density weights shape incompatible. Using unweighted convergence.")
                weights = None
        else:
            weights = density_weights
        
        if weights is not None:
            # Calculate weighted metrics for each species and take max
            weighted_diff = np.max([np.sum(weights * rel_diff[..., i]) for i in range(current_temp_adapted.shape[-1])])
        else:
            weighted_diff = None
    else:
        weighted_diff = None
    
    # Determine convergence
    is_converged = max_diff < threshold
    
    if return_details:
        metrics = {
            'max_diff': max_diff,
            'mean_diff': mean_diff,
            'median_diff': median_diff,
            'p90_diff': p90_diff,
            'weighted_diff': weighted_diff,
            'converged': is_converged
        }
        return metrics
    else:
        return is_converged

def run_radmc3d(cmd='mctherm', params=None, verbose=True):
    """
    Run RADMC-3D with the specified command and parameters.
    
    Parameters:
    -----------
    cmd : str
        RADMC-3D command (e.g., 'mctherm', 'image', 'sed')
    params : dict
        Dictionary of parameters to pass to RADMC-3D
    verbose : bool
        Whether to print RADMC-3D output
        
    Returns:
    --------
    int
        Return code from RADMC-3D
    """
    # Build command
    command = ['radmc3d']
    
    # Add command
    command.append(cmd)
    
    # Add parameters
    if params:
        for key, value in params.items():
            command.append(f"{key}={value}")
    
    # Convert command list to string
    command_str = ' '.join(command)
    
    # Print command
    if verbose:
        print(f"Running: {command_str}")
    
    # Run command - will be executed in current directory (which should be output_dir)
    process = subprocess.Popen(command_str, shell=True)
    process.communicate()
    return process.returncode

def read_radmc3d_params(filename='radmc3d.inp'):
    """
    Read the RADMC-3D parameter file and return a dictionary of parameters.
    
    Parameters:
    -----------
    filename : str
        Path to the RADMC-3D parameter file
        
    Returns:
    --------
    dict
        Dictionary of parameters
    """
    params = {}
    
    try:
        with open(filename, 'r') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Try to convert to appropriate type
                    try:
                        # First try integer
                        params[key] = int(value)
                    except ValueError:
                        try:
                            # Then try float
                            params[key] = float(value)
                        except ValueError:
                            # Finally, keep as string
                            params[key] = value
                else:
                    # Handle parameter files with no equals sign
                    parts = line.split()
                    if len(parts) >= 2:
                        key = parts[0].strip()
                        value = parts[1].strip()
                        
                        # Try to convert to appropriate type
                        try:
                            params[key] = int(value)
                        except ValueError:
                            try:
                                params[key] = float(value)
                            except ValueError:
                                params[key] = value
    except FileNotFoundError:
        print(f"Warning: Parameter file {filename} not found.")
    
    return params

def save_temperature_history(temp_history, filename='temperature_history.npy'):
    """
    Save the temperature history to a NumPy file.
    
    Parameters:
    -----------
    temp_history : list
        List of temperature data arrays
    filename : str
        Output filename
    """
    np.save(filename, temp_history)

def load_temperature_history(filename='temperature_history.npy'):
    """
    Load the temperature history from a NumPy file.
    
    Parameters:
    -----------
    filename : str
        Input filename
        
    Returns:
    --------
    list
        List of temperature data arrays
    """
    return np.load(filename, allow_pickle=True)

def plot_convergence_history(metrics_history, nphotons_history, save_fig=False, filename=None,
                             metrics_to_plot=None, threshold=0.01, show_fig=False):
    """
    Plot the convergence history with multiple metrics.
    
    Parameters:
    -----------
    metrics_history : list of dict
        List of metrics dictionaries for each iteration
    nphotons_history : list
        List of number of photons used
    save_fig : bool
        Whether to save the figure
    filename : str
        Output filename if save_fig is True
    metrics_to_plot : list
        List of metric names to plot (default: all available)
    threshold : float
        Convergence threshold to plot as horizontal line
    show_fig : bool
        Whether to display the figure (default: False)
    """
    if not metrics_history:
        print("No metrics to plot")
        return
    
    # If metrics_history contains only floats (max_diff), convert to dict format
    if isinstance(metrics_history[0], (int, float)):
        metrics_history = [{'max_diff': diff} for diff in metrics_history]
    
    # Get all available metrics if not specified
    if metrics_to_plot is None:
        metrics_to_plot = metrics_history[0].keys()
    
    fig = plt.figure(figsize=(12, 8))
    
    for metric in metrics_to_plot:
        if metric in metrics_history[0]:
            # Extract metric values, skipping None values
            values = [m.get(metric) for m in metrics_history if m.get(metric) is not None]
            
            # Only plot if we have values
            if values:
                plt.loglog(nphotons_history[:len(values)], values, 'o-', linewidth=2, label=metric)
    
    # Plot threshold line
    plt.axhline(y=threshold, color='red', linestyle='--', alpha=0.7, label=f'Threshold ({threshold})')
    
    plt.xlabel('Number of photons')
    plt.ylabel('Relative difference')
    plt.grid(True, which='both', linestyle='--', alpha=0.7)
    plt.title('Convergence History')
    plt.legend()
    
    if save_fig and filename:
        plt.savefig(filename, dpi=300, bbox_inches='tight')
    
    if show_fig:
        plt.show()
    else:
        plt.close(fig)

def plot_temperature_dependent_summary(metrics_history, cells_changed_history, iterations=None,
                                       temp_threshold=0.05, cells_change_threshold=1.0,
                                       save_fig=False, filename=None, show_fig=False):
    """
    Plot a summary of temperature-dependent iterations showing both temperature
    convergence metrics and cells changing temperature groups.
    
    Parameters:
    -----------
    metrics_history : list of dict
        List of metrics dictionaries for each iteration
    cells_changed_history : list
        List of percentages of cells that changed temperature groups
    iterations : list
        List of iteration numbers (default: 1 to n)
    temp_threshold : float
        Temperature convergence threshold to plot as horizontal line
    cells_change_threshold : float
        Threshold for cells changing temperature groups (percentage)
    save_fig : bool
        Whether to save the figure
    filename : str
        Output filename if save_fig is True
    show_fig : bool
        Whether to display the figure (default: False)
        
    Returns:
    --------
    None
    """
    if not metrics_history or not cells_changed_history:
        print("No metrics or cells changed data to plot")
        return
    
    # Create iterations list if not provided
    if iterations is None:
        iterations = np.arange(1, len(metrics_history) + 1)
    
    # Create figure with two subplots sharing the x axis
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 12), sharex=True)
    
    # Plot temperature convergence metrics
    if len(metrics_history) > 0:
        max_diffs = [m['max_diff'] * 100 for m in metrics_history]
        mean_diffs = [m['mean_diff'] * 100 for m in metrics_history]
        median_diffs = [m['median_diff'] * 100 for m in metrics_history]
        p90_diffs = [m['p90_diff'] * 100 for m in metrics_history]
        
        ax1.plot(iterations, max_diffs, 'o-', label='Maximum Difference', color='red', linewidth=2)
        ax1.plot(iterations, mean_diffs, 's-', label='Mean Difference', color='blue', linewidth=2)
        ax1.plot(iterations, median_diffs, '^-', label='Median Difference', color='green', linewidth=2)
        ax1.plot(iterations, p90_diffs, 'x-', label='90th Percentile', color='purple', linewidth=2)
        
        # Add horizontal line for temperature threshold
        ax1.axhline(y=temp_threshold * 100, color='red', linestyle='--', alpha=0.6, 
                    label=f'Threshold ({temp_threshold * 100:.1f}%)')
        
        # Set y-axis to logarithmic scale
        ax1.set_yscale('log')
        
        ax1.set_ylabel('Temperature Difference (%) - Log Scale', fontsize=12)
        ax1.set_title('Temperature Convergence Metrics', fontsize=14)
        ax1.grid(True, alpha=0.3)
        ax1.legend(fontsize=10)
    
    # Plot cells changing temperature groups
    if len(cells_changed_history) > 0:
        ax2.plot(iterations, cells_changed_history, 'o-', label='Cells Changed Groups', 
                color='darkblue', linewidth=2, markersize=8)
        
        # Add horizontal line at the cells change threshold
        ax2.axhline(y=cells_change_threshold, color='darkblue', linestyle='--', alpha=0.6, 
                    label=f'{cells_change_threshold:.1f}% Threshold')
        
        ax2.set_xlabel('Iteration', fontsize=12)
        ax2.set_ylabel('Cells Changed Temperature Group (%)', fontsize=12)
        ax2.set_title('Cells Changing Temperature Group Between Iterations', fontsize=14)
        ax2.grid(True, alpha=0.3)
        ax2.legend(fontsize=10)
    
    # Add overall title
    plt.suptitle('Temperature-Dependent Dust Opacity Convergence Summary', fontsize=16, y=0.98)
    
    plt.tight_layout(rect=[0, 0, 1, 0.96])  # Leave room for suptitle
    
    if save_fig and filename:
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"Saved temperature-dependent iteration summary to {filename}")
    
    if show_fig:
        plt.show()
    else:
        plt.close(fig)

def analyze_temperature_distribution(temp_data, grid_info, species=0, bins=50, 
                                    save_fig=False, filename=None, show_fig=False):
    """
    Analyze and plot the distribution of temperatures in the model.
    
    Parameters:
    -----------
    temp_data : ndarray
        Temperature data from read_dust_temperature()
    grid_info : dict
        Grid information
    species : int
        Dust species index
    bins : int
        Number of histogram bins
    save_fig : bool
        Whether to save the figure
    filename : str
        Output filename if save_fig is True
    show_fig : bool
        Whether to display the figure (default: False)
        
    Returns:
    --------
    dict
        Dictionary with temperature statistics
    """
    # Extract temperatures for the specified species
    if len(temp_data.shape) == 3:  # [nr, ntheta, nspec]
        temps = temp_data[:, :, species].flatten()
    elif len(temp_data.shape) == 4:  # [nr, ntheta, nphi, nspec]
        temps = temp_data[:, :, :, species].flatten()
    else:
        print(f"Warning: Unexpected temperature array shape: {temp_data.shape}")
        return None
    
    # Create figure
    fig = plt.figure(figsize=(10, 6))
    
    # Plot histogram
    n, bins, patches = plt.hist(temps, bins=bins, alpha=0.7, color='navy')
    
    # Add vertical lines for statistics
    plt.axvline(np.min(temps), color='red', linestyle='--', label=f'Min: {np.min(temps):.1f} K')
    plt.axvline(np.max(temps), color='green', linestyle='--', label=f'Max: {np.max(temps):.1f} K')
    plt.axvline(np.mean(temps), color='orange', linestyle='-', label=f'Mean: {np.mean(temps):.1f} K')
    plt.axvline(np.median(temps), color='purple', linestyle='-', label=f'Median: {np.median(temps):.1f} K')
    
    plt.xlabel('Temperature [K]')
    plt.ylabel('Number of cells')
    plt.title(f'Temperature Distribution (species {species})')
    plt.legend()
    plt.grid(True, alpha=0.3)
    
    if save_fig and filename:
        plt.savefig(filename, dpi=300, bbox_inches='tight')
    
    if show_fig:
        plt.show()
    else:
        plt.close(fig)
    
    # Return some statistics
    stats = {
        'min': np.min(temps),
        'max': np.max(temps),
        'mean': np.mean(temps),
        'median': np.median(temps),
        'std': np.std(temps),
        'p10': np.percentile(temps, 10),
        'p90': np.percentile(temps, 90)
    }
    
    return stats

def plot_advanced_temperature_density(grid_info=None, temp_data=None, density_data=None, 
                                 output_dir='figures', species=0, slice_phi=0,
                                 temp_contours=20, save_fig=True, show_fig=False,
                                 iteration=None, multi_species_handling='specific',
                                 create_zone_map=False):
    """
    Create enhanced visualizations of dust temperature and density.
    
    Parameters:
    -----------
    grid_info : dict
        Grid information dictionary
    temp_data : ndarray
        Temperature data from read_dust_temperature()
    density_data : ndarray
        Density data from read_dust_density()
    output_dir : str
        Directory to save figures
    species : int
        Dust species index
    slice_phi : int
        Phi index for 2D slices
    temp_contours : int or list
        Number of contour levels or list of specific levels
    save_fig : bool
        Whether to save figures
    show_fig : bool
        Whether to show figures interactively
    iteration : int, optional
        Iteration number to include in plot titles
    multi_species_handling : str
        How to handle multiple species: 'specific' (use the species index),
        'average' (average over all species), 'weighted_avg' (density-weighted average),
        or 'all' (plot all species)
    create_zone_map : bool
        Whether to create a dedicated temperature zone map highlighting the different
        temperature regions (below 50K, 50-150K, 150-250K, above 250K)
        
    Returns:
    --------
    dict
        Dictionary with temperature statistics
    """
    import matplotlib.pyplot as plt
    import numpy as np
    import os
    from matplotlib.colors import LogNorm, BoundaryNorm
    
    # Create output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)
    
    # Read data if not provided
    if grid_info is None:
        if os.path.exists('amr_grid.inp'):
            _, grid_info = read_dust_temperature()
        else:
            raise ValueError("Grid information is required but amr_grid.inp not found")
    
    if temp_data is None:
        if os.path.exists('dust_temperature.dat'):
            temp_data, _ = read_dust_temperature()
        else:
            raise ValueError("Temperature data is required but dust_temperature.dat not found")
    
    if density_data is None:
        if os.path.exists('dust_density.inp'):
            try:
                density_data, _, _, _ = read_dust_density(grid_info=grid_info)
            except Exception as e:
                print(f"Warning: Could not read density data: {e}")
                density_data = None
        else:
            print("Warning: dust_density.inp not found, skipping density plots")
    
    # Print data shapes for debugging
    print(f"Temperature data shape: {temp_data.shape}")
    if density_data is not None:
        print(f"Density data shape: {density_data.shape}")
    
    # Extract grid coordinates
    if grid_info['type'] == 'spherical':
        # For spherical coordinates
        r = grid_info['ri']  # Cell boundaries for r
        theta = grid_info['thetai']  # Cell boundaries for theta
        phi = grid_info['phii'] if 'phii' in grid_info else None  # Cell boundaries for phi
        
        # Create meshgrid for plotting
        R, Theta = np.meshgrid(r, theta)
        X = R * np.sin(Theta)
        Y = R * np.cos(Theta)
        
        # Get cell centers for plotting
        r_centers = grid_info['rc']  # Cell centers for r
        theta_centers = grid_info['thetac']  # Cell centers for theta
        R_centers, Theta_centers = np.meshgrid(r_centers, theta_centers)
        X_centers = R_centers * np.sin(Theta_centers)
        Y_centers = R_centers * np.cos(Theta_centers)
        
        # Get number of dust species
        n_species = temp_data.shape[-1]
        print(f"Number of dust species: {n_species}")
        
        # Handle multi-species data based on the specified approach
        if n_species > 1 and multi_species_handling != 'specific':
            if multi_species_handling == 'average':
                # Simple average across all species
                if len(temp_data.shape) == 3:  # 2D case (r, theta, species)
                    temp_slice = np.mean(temp_data, axis=2).T
                else:  # 3D case (r, theta, phi, species)
                    temp_slice = np.mean(temp_data[:, :, slice_phi, :], axis=2).T
                
                species_label = "avg"
            elif multi_species_handling == 'weighted_avg' and density_data is not None:
                # Density-weighted average
                if len(temp_data.shape) == 3:  # 2D case
                    # Calculate weights
                    weights = density_data / np.sum(density_data, axis=2, keepdims=True)
                    # Calculate weighted average
                    temp_slice = np.sum(temp_data * weights, axis=2).T
                else:  # 3D case
                    weights = density_data[:, :, slice_phi, :] / np.sum(density_data[:, :, slice_phi, :], axis=3, keepdims=True)
                    temp_slice = np.sum(temp_data[:, :, slice_phi, :] * weights, axis=3).T
                
                species_label = "weighted"
            elif multi_species_handling == 'all':
                # We'll handle this separately (plotting multiple panels)
                temp_slice = None
                species_label = "all"
            else:
                # Fall back to specific species if other methods can't be applied
                if len(temp_data.shape) == 3:  # 2D case
                    temp_slice = temp_data[:, :, min(species, n_species-1)].T
                else:  # 3D case
                    temp_slice = temp_data[:, :, slice_phi, min(species, n_species-1)].T
                
                species_label = str(min(species, n_species-1))
        else:
            # Handle single species or specific species from multi-species
            if len(temp_data.shape) == 3:  # 2D case (r, theta, species)
                # For 2D data, we need to transpose to get (theta, r) for plotting
                temp_slice = temp_data[:, :, min(species, n_species-1)].T
            elif len(temp_data.shape) == 4:  # 3D case (r, theta, phi, species)
                # For 3D data, we need to select a phi slice and transpose
                temp_slice = temp_data[:, :, slice_phi, min(species, n_species-1)].T
            else:
                raise ValueError(f"Unexpected temperature data shape: {temp_data.shape}")
            
            species_label = str(min(species, n_species-1))
        
        # Handle density data similarly
        if density_data is not None:
            if len(density_data.shape) == 3:  # 2D case
                density_slice = density_data[:, :, min(species, density_data.shape[2]-1)].T
            elif len(density_data.shape) == 4:  # 3D case
                density_slice = density_data[:, :, slice_phi, min(species, density_data.shape[3]-1)].T
            else:
                density_data = None
    
    elif grid_info['type'] == 'cartesian':
        # For cartesian coordinates - adjust as needed
        raise NotImplementedError("Cartesian coordinates not yet implemented for advanced plots")
    else:
        raise ValueError(f"Unknown grid type: {grid_info['type']}")
    
    # 1. Plot density if available
    if density_data is not None and multi_species_handling != 'all':
        # Skip individual species density plots for intermediate iterations
        # Only plot for the final result (when iteration is None)
        if iteration is None:
            plt.figure(figsize=(10, 8))
            im = plt.pcolormesh(X/au, Y/au, 
                               np.log10(density_slice),
                               shading='auto')
            plt.colorbar(im, label='log₁₀(density) [g/cm³]')
            plt.axis('equal')
            plt.xlabel('R [AU]')
            plt.ylabel('z [AU]')
            
            plt.title(f'Log Dust Density (R-z plane, species {species_label})')
                
            if save_fig:
                density_filename = os.path.join(output_dir, f'dust_density_species{species_label}')
                density_filename += '.png'
                plt.savefig(density_filename, dpi=300, bbox_inches='tight')
            if not show_fig:
                plt.close()
    
    # Special case for 'all' - create a panel of plots for each species
    if multi_species_handling == 'all' and n_species > 1:
        # Determine grid layout
        n_rows = 2
        n_cols = (n_species + 1) // 2  # Ceiling division
        
        # First create the temperature panel
        fig = plt.figure(figsize=(12*n_cols/2, 8*n_rows/2))
        
        for i in range(n_species):
            plt.subplot(n_rows, n_cols, i+1)
            
            if len(temp_data.shape) == 3:  # 2D case
                temp_slice_i = temp_data[:, :, i].T
            else:  # 3D case
                temp_slice_i = temp_data[:, :, slice_phi, i].T
            
            im = plt.pcolormesh(X/au, Y/au, temp_slice_i, cmap='inferno', shading='auto')
            plt.colorbar(im, label='Temperature [K]')
            plt.axis('equal')
            plt.xlabel('R [AU]')
            plt.ylabel('z [AU]')
            plt.title(f'Species {i}')
        
        # Create a tight layout
        plt.tight_layout()
        
        # Add a title for the whole figure
        if iteration is not None:
            plt.suptitle(f'Dust Temperature - Iteration {iteration} (All Species)', 
                       fontsize=16, y=0.98)
        else:
            plt.suptitle(f'Dust Temperature (All Species)', fontsize=16, y=0.98)
        
        if save_fig:
            temp_filename = os.path.join(output_dir, 'dust_temperature_all_species')
            if iteration is not None:
                temp_filename += f'_iter{iteration}'
            temp_filename += '.png'
            plt.savefig(temp_filename, dpi=300, bbox_inches='tight')
        
        if not show_fig:
            plt.close()
            
        # Now create a density panel if density data is available
        if density_data is not None:
            fig = plt.figure(figsize=(12*n_cols/2, 8*n_rows/2))
            
            for i in range(n_species):
                plt.subplot(n_rows, n_cols, i+1)
                
                if len(density_data.shape) == 3:  # 2D case
                    density_slice_i = density_data[:, :, i].T
                else:  # 3D case
                    density_slice_i = density_data[:, :, slice_phi, i].T
                
                im = plt.pcolormesh(X/au, Y/au, np.log10(density_slice_i), 
                                   cmap='viridis', shading='auto')
                plt.colorbar(im, label='log₁₀(density) [g/cm³]')
                plt.axis('equal')
                plt.xlabel('R [AU]')
                plt.ylabel('z [AU]')
                plt.title(f'Species {i}')
            
            # Create a tight layout
            plt.tight_layout()
            
            # Add a title for the whole figure
            if iteration is not None:
                plt.suptitle(f'Dust Density - Iteration {iteration} (All Species)', 
                           fontsize=16, y=0.98)
            else:
                plt.suptitle(f'Dust Density (All Species)', fontsize=16, y=0.98)
            
            if save_fig:
                density_filename = os.path.join(output_dir, 'dust_density_all_species')
                if iteration is not None:
                    density_filename += f'_iter{iteration}'
                density_filename += '.png'
                plt.savefig(density_filename, dpi=300, bbox_inches='tight')
            
            if not show_fig:
                plt.close()
        
        # Create a temperature zone panel (this is done in create_zone_map section)
    
    # 2. Plot temperature (standard) - skip if 'all' is chosen
    if multi_species_handling != 'all':
        plt.figure(figsize=(10, 8))
        im = plt.pcolormesh(X/au, Y/au, 
                          temp_slice,
                          cmap='inferno', shading='auto')
        plt.colorbar(im, label='Temperature [K]')
        plt.axis('equal')
        plt.xlabel('R [AU]')
        plt.ylabel('z [AU]')
        
        if iteration is not None:
            plt.title(f'Dust Temperature - Iteration {iteration} (R-z plane, species {species_label})')
        else:
            plt.title(f'Dust Temperature (R-z plane, species {species_label})')
            
        if save_fig:
            temp_filename = os.path.join(output_dir, f'dust_temperature_species{species_label}')
            if iteration is not None:
                temp_filename += f'_iter{iteration}'
            temp_filename += '.png'
            plt.savefig(temp_filename, dpi=300, bbox_inches='tight')
        if not show_fig:
            plt.close()
        
        # 3. Create temperature zone map with contours
        plt.figure(figsize=(12, 10))
        
        # Define temperature zones with distinct colors
        cmap = plt.cm.colors.ListedColormap(['#3498db', '#2ecc71', '#f39c12', '#e74c3c'])
        try:
            max_temp = np.max(temp_slice) if temp_slice is not None else 300
            bounds = [0, 50, 150, 250, max(300, max_temp)]
        except (TypeError, ValueError):
            print("Warning: Could not calculate max temperature from temperature slice - using default bounds")
            bounds = [0, 50, 150, 250, 300]
        norm = BoundaryNorm(bounds, cmap.N)
        
        # Create the main color zone plot
        im = plt.pcolormesh(X_centers/au, Y_centers/au, 
                          temp_slice,
                          cmap=cmap, norm=norm, shading='auto')
        
        # Add contour lines to show temperature boundaries
        try:
            if temp_slice is not None:
                contours = plt.contour(X_centers/au, Y_centers/au, temp_slice, 
                                levels=[50, 150, 250], colors='white', linewidths=1.5)
                plt.clabel(contours, inline=True, fontsize=10, fmt='%dK')
        except Exception as e:
            print(f"Warning: Could not create temperature contours: {e}")
            # Continue without contours
        
        # Add colorbar
        ticks = [25, min(100, max_temp/2), min(200, max_temp*0.75), min(max_temp*0.9, 300)]
        cbar = plt.colorbar(im, ticks=ticks)
        cbar.set_label('Temperature [K]')
        cbar.ax.set_yticklabels(['<50K', '50-150K', '150-250K', '>250K'])
        
        plt.axis('equal')
        plt.xlabel('R [AU]')
        plt.ylabel('z [AU]')
        
        if iteration is not None:
            plt.title(f'Dust Temperature Zones - Iteration {iteration} (R-z plane, species {species_label})')
        else:
            plt.title(f'Dust Temperature Zones (R-z plane, species {species_label})')
        
        if save_fig:
            zone_filename = os.path.join(output_dir, f'temperature_zones_map_species{species_label}')
            if iteration is not None:
                zone_filename += f'_iter{iteration}'
            zone_filename += '.png'
            plt.savefig(zone_filename, dpi=300, bbox_inches='tight')
        if not show_fig:
            plt.close()
    
    # 4. Analyze temperature distribution
    # Flatten the temperature array for the specified dust species (or averaged/all species)
    if multi_species_handling == 'average':
        # Use average across all species
        if len(temp_data.shape) == 3:  # 2D case (r, theta, species)
            temp_flat = np.mean(temp_data, axis=2).flatten()
        elif len(temp_data.shape) == 4:  # 3D case (r, theta, phi, species)
            temp_flat = np.mean(temp_data, axis=3).flatten()
    elif multi_species_handling == 'weighted_avg' and density_data is not None:
        # Use density-weighted average
        if len(temp_data.shape) == 3:  # 2D case
            weights = density_data / np.sum(density_data, axis=2, keepdims=True)
            temp_flat = np.sum(temp_data * weights, axis=2).flatten()
        elif len(temp_data.shape) == 4:  # 3D case
            weights = density_data / np.sum(density_data, axis=3, keepdims=True)
            temp_flat = np.sum(temp_data * weights, axis=3).flatten()
    else:
        # Use specific species
        if len(temp_data.shape) == 3:  # 2D case (r, theta, species)
            temp_flat = temp_data[:, :, min(species, n_species-1)].flatten()
        elif len(temp_data.shape) == 4:  # 3D case (r, theta, phi, species)
            temp_flat = temp_data[:, :, :, min(species, n_species-1)].flatten()
        else:
            raise ValueError(f"Unexpected temperature data shape: {temp_data.shape}")
    
    # Count cells in different temperature ranges
    below_50K = np.sum(temp_flat < 50)
    between_50_150K = np.sum((temp_flat >= 50) & (temp_flat < 150))
    between_150_250K = np.sum((temp_flat >= 150) & (temp_flat < 250))
    above_250K = np.sum(temp_flat >= 250)
    
    # Print the counts and percentages
    total_cells = len(temp_flat)
    print(f"\nTemperature distribution for {'all species' if multi_species_handling in ['average', 'weighted_avg'] else f'dust species {species_label}'}:")
    print(f"Below 50K: {below_50K} cells ({below_50K/total_cells*100:.2f}%)")
    print(f"50K-150K: {between_50_150K} cells ({between_50_150K/total_cells*100:.2f}%)")
    print(f"150K-250K: {between_150_250K} cells ({between_150_250K/total_cells*100:.2f}%)")
    print(f"Above 250K: {above_250K} cells ({above_250K/total_cells*100:.2f}%)")
    
    # Collect stats for return
    stats = {
        'below_50K': below_50K,
        'between_50_150K': between_50_150K,
        'between_150_250K': between_150_250K,
        'above_250K': above_250K,
        'total_cells': total_cells,
        'max_temperature': np.max(temp_flat),
        'min_temperature': np.min(temp_flat),
        'mean_temperature': np.mean(temp_flat),
        'median_temperature': np.median(temp_flat)
    }
    
    # Create a dedicated temperature zone map if requested
    if create_zone_map:
        try:
            # Special case for 'all' species mode
            if multi_species_handling == 'all' and n_species > 1:
                # Create a panel of temperature zone maps for each species
                n_rows = 2
                n_cols = (n_species + 1) // 2  # Ceiling division
                
                fig = plt.figure(figsize=(12*n_cols/2, 8*n_rows/2))
                
                # Define temperature zones with distinct colors
                cmap = plt.cm.colors.ListedColormap(['#3498db', '#2ecc71', '#f39c12', '#e74c3c'])
                bounds = [0, 50, 150, 250, 300]
                norm = BoundaryNorm(bounds, cmap.N)
                
                for i in range(n_species):
                    plt.subplot(n_rows, n_cols, i+1)
                    
                    # Get temperature slice for this species
                    if len(temp_data.shape) == 3:  # 2D case
                        temp_slice_i = temp_data[:, :, i].T
                    else:  # 3D case
                        temp_slice_i = temp_data[:, :, slice_phi, i].T
                    
                    # Create the temperature zone map for this species
                    im = plt.pcolormesh(X_centers/au, Y_centers/au, 
                                      temp_slice_i,
                                      cmap=cmap, norm=norm, shading='auto')
                    
                    plt.axis('equal')
                    plt.xlabel('R [AU]', fontsize=8)
                    plt.ylabel('z [AU]', fontsize=8)
                    plt.title(f'Species {i}', fontsize=10)
                
                # Create a tight layout with space for the colorbar
                plt.tight_layout(rect=[0, 0, 0.9, 0.9])
                
                # Add a colorbar on the side of the existing figure
                cbar = fig.colorbar(im, ax=fig.axes, orientation='vertical', shrink=0.8)
                cbar.set_label('Temperature Zones')
                cbar.set_ticks([25, 100, 200, 275])
                cbar.set_ticklabels(['< 50K', '50K - 150K', '150K - 250K', '> 250K'])
                
                # Add a title for the whole figure
                if iteration is not None:
                    plt.suptitle(f'Temperature Zones - Iteration {iteration} (All Species)', 
                               fontsize=16, y=0.98)
                else:
                    plt.suptitle(f'Temperature Zones (All Species)', fontsize=16, y=0.98)
                
                if save_fig:
                    zone_filename = os.path.join(output_dir, 'temperature_zones_map_all_species')
                    if iteration is not None:
                        zone_filename += f'_iter{iteration}'
                    zone_filename += '.png'
                    plt.savefig(zone_filename, dpi=300, bbox_inches='tight')
                
                if not show_fig:
                    plt.close()
                
                return stats
            
            # Check if all required variables exist and are valid
            if temp_slice is None or X_centers is None or Y_centers is None:
                print("Warning: Cannot create temperature zone map - missing data")
                return stats
                
            # Now proceed with plotting
            plt.figure(figsize=(12, 10))
            
            # Define temperature zones with distinct colors
            cmap = plt.cm.colors.ListedColormap(['#3498db', '#2ecc71', '#f39c12', '#e74c3c'])
            try:
                max_temp = np.max(temp_slice) if temp_slice is not None else 300
                bounds = [0, 50, 150, 250, max(300, max_temp)]
            except (TypeError, ValueError):
                print("Warning: Could not calculate max temperature from temperature slice - using default bounds")
                bounds = [0, 50, 150, 250, 300]
            norm = BoundaryNorm(bounds, cmap.N)
            
            # Create the temperature zone map
            im = plt.pcolormesh(X_centers/au, Y_centers/au, 
                              temp_slice,
                              cmap=cmap, norm=norm, shading='auto')
            
            # Add a grid for better visibility of zones
            plt.grid(True, color='white', linestyle='--', alpha=0.3)
            
            # Create a custom colorbar with labels for each zone
            cbar = plt.colorbar(im, ticks=[25, 100, 200, 275])
            cbar.set_label('Temperature Zones')
            cbar.ax.set_yticklabels(['< 50K', '50K - 150K', '150K - 250K', '> 250K'])
            
            plt.axis('equal')
            plt.xlabel('R [AU]')
            plt.ylabel('z [AU]')
            
            title_species = "all species" if multi_species_handling in ['average', 'weighted_avg'] else f"species {species_label}"
            if iteration is not None:
                plt.title(f'Temperature Zones - Iteration {iteration} ({title_species})')
            else:
                plt.title(f'Temperature Zones ({title_species})')
            
            if save_fig:
                zone_filename = os.path.join(output_dir, f'temperature_zones_map_{title_species.replace(" ", "_")}')
                if iteration is not None:
                    zone_filename += f'_iter{iteration}'
                zone_filename += '.png'
                plt.savefig(zone_filename, dpi=300, bbox_inches='tight')
            
            if not show_fig:
                plt.close()
        
        except Exception as e:
            print(f"Warning: Error creating temperature zone map: {e}")
            # Continue with function despite visualization error
    
    return stats

def read_amr_grid(filename='amr_grid.inp'):
    """
    Read AMR grid information from a RADMC-3D grid file.
    
    Parameters:
    -----------
    filename : str
        Name of the AMR grid file
        
    Returns:
    --------
    dict
        Grid information dictionary with grid type, dimensions, and arrays
    """
    import numpy as np
    import os
    
    if not os.path.exists(filename):
        raise FileNotFoundError(f"Grid file {filename} not found")
    
    # Read the AMR grid file
    with open(filename, 'r') as f:
        iformat = int(f.readline().strip())
        grid_style = int(f.readline().strip())
        coordsystem = int(f.readline().strip())
        gridinfo = int(f.readline().strip())
        
        # Read which coordinates are included
        line = f.readline().strip().split()
        incl_r = int(line[0])
        incl_theta = int(line[1])
        incl_phi = int(line[2]) if len(line) > 2 else 0
        
        # Read grid dimensions
        line = f.readline().strip().split()
        nr = int(line[0])
        ntheta = int(line[1])
        nphi = int(line[2]) if len(line) > 2 else 1
        
        # Read cell walls
        ri = np.zeros(nr+1)
        for i in range(nr+1):
            ri[i] = float(f.readline().strip())
            
        thetai = np.zeros(ntheta+1)
        for i in range(ntheta+1):
            thetai[i] = float(f.readline().strip())
            
        phii = np.zeros(nphi+1)
        for i in range(nphi+1):
            phii[i] = float(f.readline().strip())
    
    # Determine grid type
    grid_type = 'cartesian'
    if coordsystem == 100:
        grid_type = 'spherical'
    elif coordsystem == 200:
        grid_type = 'cylindrical'
        
    # Calculate cell centers
    rc = 0.5 * (ri[1:] + ri[:-1])
    thetac = 0.5 * (thetai[1:] + thetai[:-1])
    phic = 0.5 * (phii[1:] + phii[:-1])
    
    # Create meshgrid for r, theta (for 2D case)
    rr, tt = np.meshgrid(rc, thetac, indexing='ij')
    
    # Create grid info dictionary
    grid_info = {
        'type': grid_type,
        'nr': nr,
        'ntheta': ntheta,
        'nphi': nphi,
        'ri': ri,
        'thetai': thetai,
        'phii': phii,
        'rc': rc,
        'thetac': thetac,
        'phic': phic,
        'rr': rr,
        'tt': tt
    }
    
    # Add cartesian-specific info
    if grid_type == 'cartesian':
        grid_info.update({
            'nx': nr,
            'ny': ntheta,
            'nz': nphi,
            'xi': ri,
            'yi': thetai,
            'zi': phii,
            'xc': rc,
            'yc': thetac,
            'zc': phic
        })
    
    return grid_info

def read_dust_density(filename='dust_density.inp', grid_info=None):
    """
    Read dust density data from RADMC-3D output file.
    
    Parameters:
    -----------
    filename : str
        Name of the dust density file
    grid_info : dict, optional
        Grid information dictionary. If not provided, will try to read from amr_grid.inp
        
    Returns:
    --------
    ndarray
        Dust density array with shape [nr, ntheta, nphi, nspec] or [nr, ntheta, nspec]
    dict
        Grid information dictionary
    int
        Number of cells
    int
        Number of species
    """
    import numpy as np
    import os
    
    # If grid_info not provided, try to read it
    if grid_info is None:
        if os.path.exists('amr_grid.inp'):
            _, grid_info = read_dust_temperature(filename='dust_temperature.dat')
        else:
            raise ValueError("Grid information must be provided or amr_grid.inp must exist")
    
    # Extract grid dimensions based on grid type
    if grid_info['type'] == 'spherical':
        nr = grid_info['nr']
        ntheta = grid_info['ntheta']
        nphi = grid_info.get('nphi', 1)  # Default to 1 if not present (2D case)
    elif grid_info['type'] == 'cartesian':
        nr = grid_info['nx']
        ntheta = grid_info['ny']
        nphi = grid_info['nz']
    else:
        raise ValueError(f"Unknown grid type: {grid_info['type']}")
    
    # Total number of cells
    ncells = nr * ntheta * nphi
    
    try:
        with open(filename, 'r') as f:
            # Read the header
            iformat = int(f.readline().strip())
            nrcells = int(f.readline().strip())
            nrspec = int(f.readline().strip())
            
            # Verify cell count matches grid
            if nrcells != ncells:
                print(f"Warning: Cell count mismatch. File has {nrcells}, grid has {ncells}")
            
            # Read densities for each species
            densities = []
            for ispec in range(nrspec):
                species_density = []
                for _ in range(nrcells):
                    species_density.append(float(f.readline().strip()))
                densities.append(np.array(species_density))
        
        # Convert to numpy array
        densities = np.array(densities)  # Shape: [nrspec, nrcells]
        
        # Reshape based on grid type and dimensionality
        if grid_info['type'] == 'spherical':
            if nphi == 1:
                # 2D case (r, theta)
                densities = densities.reshape(nrspec, ntheta, nr)
                # Transpose to get [nr, ntheta, nrspec]
                densities = densities.transpose(2, 1, 0)
            else:
                # 3D case (r, theta, phi)
                densities = densities.reshape(nrspec, nphi, ntheta, nr)
                # Transpose to get [nr, ntheta, nphi, nrspec]
                densities = densities.transpose(3, 2, 1, 0)
        else:
            # Cartesian case
            densities = densities.reshape(nrspec, nphi, ntheta, nr)
            # Transpose to get [nr, ntheta, nphi, nrspec]
            densities = densities.transpose(3, 2, 1, 0)
        
        return densities, grid_info, nrcells, nrspec
        
    except Exception as e:
        raise Exception(f"Error reading dust density file: {e}")

def redistribute_density_by_temperature(temp_data, original_density, grid_info, temp_ranges=[50, 150, 250]):
    """
    Redistribute dust density based on temperature zones.
    
    Parameters:
    -----------
    temp_data : ndarray
        Temperature data from read_dust_temperature()
    original_density : ndarray
        Original dust density data with single species
    grid_info : dict
        Grid information dictionary
    temp_ranges : list
        Temperature range boundaries [t1, t2, t3] creating zones:
        - below t1: use 10K opacities
        - t1 to t2: use 100K opacities
        - t2 to t3: use 200K opacities
        - above t3: use 300K opacities
        
    Returns:
    --------
    ndarray
        New dust density array with 4 species distributed by temperature
    """
    import numpy as np
    import os
    
    # Determine dimensionality
    if grid_info['type'] == 'spherical':
        nr = grid_info['nr']
        ntheta = grid_info['ntheta']
        nphi = grid_info.get('nphi', 1)  # Default to 1 if not present (2D case)
    elif grid_info['type'] == 'cartesian':
        nr = grid_info['nx']
        ntheta = grid_info['ny']
        nphi = grid_info['nz']
    else:
        raise ValueError(f"Unknown grid type: {grid_info['type']}")
    
    # Print debug info about array shapes
    print(f"Temperature data shape: {temp_data.shape}")
    print(f"Original density shape: {original_density.shape}")
    
    # Create new density array for 4 species
    if len(temp_data.shape) == 3:  # 2D case [nr, ntheta, nspec]
        new_density = np.zeros((nr, ntheta, 4))
        
        # Extract temperature for the first species (or the only species)
        temp = temp_data[:, :, 0]
        
        # Extract original density (checking dimension and shape)
        if len(original_density.shape) == 3 and original_density.shape[2] > 1:
            # If original density already has multiple species, sum them
            orig_dens = np.sum(original_density, axis=2)
        elif len(original_density.shape) == 3:
            # Single species in third dimension
            orig_dens = original_density[:, :, 0]
        elif len(original_density.shape) == 2:
            # No species dimension
            orig_dens = original_density
        else:
            raise ValueError(f"Unexpected original density shape: {original_density.shape}")
        
        # Create masks for each temperature range
        mask_10K = temp < temp_ranges[0]
        mask_100K = (temp >= temp_ranges[0]) & (temp < temp_ranges[1])
        mask_200K = (temp >= temp_ranges[1]) & (temp < temp_ranges[2])
        mask_300K = temp >= temp_ranges[2]
        
        # Distribute density based on temperature
        new_density[:, :, 0] = np.where(mask_10K, orig_dens, 0)
        new_density[:, :, 1] = np.where(mask_100K, orig_dens, 0)
        new_density[:, :, 2] = np.where(mask_200K, orig_dens, 0)
        new_density[:, :, 3] = np.where(mask_300K, orig_dens, 0)
        
    elif len(temp_data.shape) == 4:  # 3D case [nr, ntheta, nphi, nspec]
        new_density = np.zeros((nr, ntheta, nphi, 4))
        
        # Extract temperature for the first species (or the only species)
        temp = temp_data[:, :, :, 0]
        
        # Extract original density (checking dimension and shape)
        if len(original_density.shape) == 4 and original_density.shape[3] > 1:
            # If original density already has multiple species, sum them
            orig_dens = np.sum(original_density, axis=3)
        elif len(original_density.shape) == 4:
            # Single species in fourth dimension
            orig_dens = original_density[:, :, :, 0]
        elif len(original_density.shape) == 3:
            # No species dimension
            orig_dens = original_density
        else:
            raise ValueError(f"Unexpected original density shape: {original_density.shape}")
        
        # Create masks for each temperature range
        mask_10K = temp < temp_ranges[0]
        mask_100K = (temp >= temp_ranges[0]) & (temp < temp_ranges[1])
        mask_200K = (temp >= temp_ranges[1]) & (temp < temp_ranges[2])
        mask_300K = temp >= temp_ranges[2]
        
        # Distribute density based on temperature
        new_density[:, :, :, 0] = np.where(mask_10K, orig_dens, 0)
        new_density[:, :, :, 1] = np.where(mask_100K, orig_dens, 0)
        new_density[:, :, :, 2] = np.where(mask_200K, orig_dens, 0)
        new_density[:, :, :, 3] = np.where(mask_300K, orig_dens, 0)
    
    # Print statistics for debugging
    print("\nDust density distribution by temperature:")
    print(f"Below {temp_ranges[0]}K (10K opacities): {np.count_nonzero(new_density[..., 0])} cells")
    print(f"{temp_ranges[0]}-{temp_ranges[1]}K (100K opacities): {np.count_nonzero(new_density[..., 1])} cells")
    print(f"{temp_ranges[1]}-{temp_ranges[2]}K (200K opacities): {np.count_nonzero(new_density[..., 2])} cells")
    print(f"Above {temp_ranges[2]}K (300K opacities): {np.count_nonzero(new_density[..., 3])} cells")
    
    return new_density

def write_temp_dependent_density(new_density, grid_info, filename='dust_density.inp'):
    """
    Write the temperature-dependent dust density to file.
    
    Parameters:
    -----------
    new_density : ndarray
        New dust density array with multiple species
    grid_info : dict
        Grid information dictionary
    filename : str
        Output filename
        
    Returns:
    --------
    None
        Writes the dust_density.inp file
    """
    # Calculate total number of cells
    if grid_info['type'] == 'spherical':
        nr = grid_info['nr']
        ntheta = grid_info['ntheta']
        nphi = grid_info.get('nphi', 1)  # Default to 1 if not present (2D case)
    elif grid_info['type'] == 'cartesian':
        nr = grid_info['nx']
        ntheta = grid_info['ny']
        nphi = grid_info['nz']
    else:
        raise ValueError(f"Unknown grid type: {grid_info['type']}")
    
    total_cells = nr * ntheta * nphi
    n_species = new_density.shape[-1]
    
    # Write the dust density file
    with open(filename, 'w') as f:
        f.write('1\n')                # Format number
        f.write(f'{total_cells}\n')   # Number of cells
        f.write(f'{n_species}\n')     # Number of dust species
        
        # Write flattened density data for each species
        for ispec in range(n_species):
            if len(new_density.shape) == 3:  # 2D case [nr, ntheta, nspec]
                data = new_density[:, :, ispec].ravel(order='F')
            else:  # 3D case [nr, ntheta, nphi, nspec]
                data = new_density[:, :, :, ispec].ravel(order='F')
                
            for value in data:
                f.write(f'{value:13.6e}\n')
    
    print(f"Wrote temperature-dependent dust density file with {n_species} species to {filename}")

def plot_initial_dust_density(grid_info=None, density_data=None, output_dir='figures', 
                              save_fig=True, show_fig=False, slice_phi=0,
                              add_annotations=True, cmap='viridis'):
    """
    Create a clear visualization of the initial dust density structure with detailed annotations.
    
    Parameters:
    -----------
    grid_info : dict, optional
        Grid information dictionary
    density_data : ndarray, optional
        Density data array
    output_dir : str
        Directory to save the figure
    save_fig : bool
        Whether to save the figure
    show_fig : bool
        Whether to show the figure
    slice_phi : int
        Phi slice index for 3D data
    add_annotations : bool
        Whether to add detailed annotations to the plot
    cmap : str
        Colormap to use
        
    Returns:
    --------
    dict or None
        Dictionary with density statistics if successful, None otherwise
    """
    try:
        import matplotlib.pyplot as plt
        import numpy as np
        import os
        
        # Create output directory if it doesn't exist
        if save_fig and not os.path.exists(output_dir):
            os.makedirs(output_dir)
        
        # Get grid info if not provided
        if grid_info is None:
            try:
                grid_info = read_amr_grid()
            except Exception as e:
                print(f"Error reading grid information: {e}")
                return None
        
        # Get density data if not provided
        if density_data is None:
            try:
                density_data, _, _, _ = read_dust_density(grid_info=grid_info)
            except Exception as e:
                print(f"Error reading density data: {e}")
                return None
        
        # Check grid type
        if grid_info['type'] != 'spherical':
            print("Error: Only spherical coordinates are supported for dust density plots")
            return None
        
        # Create coordinate grid for visualization (R-z plane)
        r = grid_info['rc']
        theta = grid_info['thetac']
        
        # Create meshgrid
        R, T = np.meshgrid(r, theta, indexing='ij')
        
        # Convert to Cartesian for visualization
        X = R * np.sin(T)
        Y = R * np.cos(T)
        
        # Extract 2D density slice based on shape
        if len(density_data.shape) == 2:
            # Already 2D data
            density_slice = density_data
        elif len(density_data.shape) == 3 and density_data.shape[-1] == 1:
            # 2D with species
            density_slice = density_data[:, :, 0]
        elif len(density_data.shape) == 3:
            # 3D data, take slice at phi=slice_phi
            density_slice = density_data[:, :, slice_phi]
        elif len(density_data.shape) == 4 and density_data.shape[-1] == 1:
            # 3D with species, take slice at phi=slice_phi
            density_slice = density_data[:, :, slice_phi, 0]
        else:
            print(f"Unsupported density data shape: {density_data.shape}")
            return None
        
        # Transpose if needed (make sure dimensions match the meshgrid)
        if X.shape != density_slice.shape:
            density_slice = density_slice.T
        
        # Create figure
        plt.figure(figsize=(16, 14))
        
        # Find appropriate colormap range (log scale)
        try:
            # Filter out zeros before taking log
            non_zero = density_slice[density_slice > 0]
            if len(non_zero) > 0:
                # Set minimum density to a physically meaningful value (-24 in log10 scale)
                vmin = max(np.log10(np.min(non_zero)), -24.0)
                vmax = np.log10(np.max(non_zero))
            else:
                # If no non-zero values, use physically meaningful defaults
                vmin, vmax = -24.0, -10.0
        except Exception:
            vmin, vmax = -24.0, -10.0
        
        # Create the plot with log scale
        pcm = plt.pcolormesh(X/au, Y/au, np.log10(density_slice),
                      cmap=cmap, shading='auto', vmin=vmin, vmax=vmax)
        
        # Add colorbar
        cbar = plt.colorbar(pcm, pad=0.01)
        cbar.set_label('log₁₀(density) [g/cm³]', size=14)
        
        # Add detailed annotations if requested
        if add_annotations:
            # Calculate statistics for annotations
            min_density = np.min(density_slice[density_slice > 0])
            max_density = np.max(density_slice)
            mean_density = np.mean(density_slice[density_slice > 0])
            median_density = np.median(density_slice[density_slice > 0])
            
            # Create stats dictionary for return
            stats = {
                'min_density': min_density,
                'max_density': max_density,
                'mean_density': mean_density,
                'median_density': median_density
            }
            
            # Add annotations showing model structure
            plt.annotate('Outflow Cavity', xy=(0, 0.9*np.max(Y)/au), xytext=(0.5*np.max(X)/au, 0.9*np.max(Y)/au),
                        arrowprops=dict(facecolor='white', shrink=0.05, width=2, headwidth=8),
                        color='white', fontsize=12)
            
            plt.annotate('Equatorial Torus', xy=(0.5*np.max(X)/au, 0), xytext=(0.7*np.max(X)/au, 0.2*np.max(Y)/au),
                        arrowprops=dict(facecolor='white', shrink=0.05, width=2, headwidth=8),
                        color='white', fontsize=12)
            
            # Add text box with density statistics
            stats_text = f"Density Statistics:\n" \
                         f"Min: {min_density:.2e} g/cm³\n" \
                         f"Max: {max_density:.2e} g/cm³\n" \
                         f"Mean: {mean_density:.2e} g/cm³\n" \
                         f"Median: {median_density:.2e} g/cm³"
            
            plt.text(0.02, 0.02, stats_text, transform=plt.gca().transAxes,
                    fontsize=12, verticalalignment='bottom', horizontalalignment='left',
                    bbox=dict(boxstyle='round,pad=0.5', facecolor='white', alpha=0.7))
        else:
            stats = None
        
        # Add axis labels and title
        plt.xlabel('Radius [AU]', size=14)
        plt.ylabel('z [AU]', size=14)
        plt.title('Initial Dust Density Structure', size=16)
        plt.axis('equal')
        plt.grid(True, linestyle='--', alpha=0.3)
        
        # Save figure if requested
        if save_fig:
            filename = f"{output_dir}/initial_dust_density_annotated.png"
            plt.savefig(filename, dpi=300, bbox_inches='tight')
        
        # Show or close figure
        if not show_fig:
            plt.close()
        
        return stats
        
    except Exception as e:
        print(f"Error in plot_initial_dust_density function: {e}")
        return None